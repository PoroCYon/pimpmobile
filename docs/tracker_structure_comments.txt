/*
Player logic:

Interface:
 - First, call init_module() to set up module processing to begin with.
    init_module() takes a pointer to the module and a flag indicating
    whether to permit backwards jump in the order.
 
 - Then, for each player tick, call the process_tick() function.
   This function processes 1 tick's worth of pattern data. It sets up the
   following data for the mixer routine:
    - Number of samples to mix for this tick.
    - For each channel:
       - Note state (
           NOTE_NONE = nothing is playing in channel
           NOTE_ACTIVE = playing note normally, 
           NOTE_KEYOFF = note currently playing has been handed a key-off
             For the mixer, NOTE_ACTIVE and NOTE_KEYOFF differ only in whether
             they honor sustein loops (NOTE_ACTIVE does, NOTE_KEYOFF doesn't)
             (sustain loops are an Impulse-Tracker-only feature)
             
       - Pointer to active sample's data structure
       - Sample cursor, cursor delta (unsigned) and sample direction flag
       - Volume and panning position to apply
    - Current play position: 
       - Order index, 
       - Pattern index, 
       - Pattern location, 
       - Tick location
      These are not modifiable; they are only supplied to assist any graphical
      displays.
   process_tick() returns FALSE if we reach the end of the module, TRUE
     otherwise.
      
 - The mixer routine can perform mixing. It is allowed 2 actions other
   than just mixing: 
    - Update sample cursor, and sample direction flag if appropriate
    - Setting note state to 0 after mixing (nothing playing)
       
 - the process_tick function basically works as follows:
    - If tick 0 
        - If and pattern-delay not active, fetch 1 row of pattern data
        - If pattern-delay active, strip a few effects off the row of
           pattern data, and decrement pattern-delay counter 
        - then analyze row for speed/tempo/flow-control commands, and assign
          a vtick index to each channel (basically minus delay if delay is 
          present, 0 otherwise. Also:
           - For effects with effect parameter = 0, remember a value
             from the channel's effect memory. For effects with effect parameter
             != 0, update the effect memory.
    - For any tick:
       - step through each channel. If vtick < 0, don't process note/effect
         If vtick == 0, trigger note if present and process 
         effects for tick0. If vtick > 0, process effects for tick >0.
    - Increment tick and all vticks.
    - If tick >= tempo
       - if flow control instruction present, 
          then execute the flow control instruction, setting order & pattern
          indices as indicated, and computing a pointer into a pattern.
       - else if pattern-delay-counter != 0, then enter into pattern-delay
       - else advance to the next step in the pattern. 
          - if we step off the end of the pattern: step to pattern of the
            next entry in the order.
       - if we stepped out of the pattern (end of pattern, or
          pattern-break/jump-to-order:
           - reset the loop-state (for all channels, if needed)
           - if the jump is backwards in the order, then check whether
              we allow backwards jumps. Flag module playing state
              as ENDED if we don't.
*/

        
enum channel_state_t {
	NOTE_NONE,
	NOTE_ACTIVE,
	NOTE_KEYOFF,

struct mixer_channel_state_t {
	channel_state_t channel_state;
	sample_t *curr_sample;
	u32 sample_cursor;
	u32 sample_cursor_delta;
	u32 sample_cursor_direction;
	};
	
            
struct mixer_state_t {
	int is_last_tick;
	int num_samples; // number of samples to actually mix
	mixer_channel_state *mixer_channel_state; // pointer to per-channel state
	// data that can be used to display current player state, if desired
	int order_pos;
	int pattern_index;
	int pattern_pos;
	int tick_location;
	int tempo;
	int BPM;
	};


class module_player_t {
	
	public:
	// interface to the module player
	module_player_t( void );
	~module_player_t( void );
	bool init_module( u8 *module_data )
	mixer_state_t *process_tick( void );
	void unload_module( void );

	// publicly available module information, that doesn't depend
	// on mixer state
	bool module_loaded;
	int num_channels;
	int order_length;
	char *module_name;
	
	
	
	}


state_t* init_module( u8 *module_data )
	{
	}

bool process_tick(mixer_state_t *mix_state)
	{
	
	
	}


            