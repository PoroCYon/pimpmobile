mixing routines for the gba XM player (mono):

versions:
 - default
 - loop-event-checker
 - bresenham
 - bresenham with volume
 - dual-channel bresenham
 - dual-channel bresenham with volume
 - lerp-default
 - lerp-bresenham

cycle-assumptions:
 - bresenham will read a sample 40% of the time
 - fetching 1 sample takes 4 clks
 - mixbuf read & write takes 5 clks
 - mul takes 2 clks


lerp_default: <23 cycles>
	smp1 = sample[cursor >> 12]
	smp2 = sample[(cursor >> 12) + 1]
	smp2 -= smp1;
	smp2 *= cursor & 0x3FF;
	smp2 += smp1 << 12;
	*mixbuf++ += smp2 * volume;
	cursor += delta;

lerp_bresenham <15.8 cycles>:
	df += diff;
	frac += delta;
	if(frac < delta)
		{
		smp1 = smp2;
		smp2 = *sample++ * volume;
		diff = (smp2 - smp1);
		df = (smp1 << 8) + diff * (frac >> 24)
		diff *= delta_shr24;
		}
	*mixbuf++ += df;
		


default: <delta not in range [0,1>, 13 clk >
	smp = sample[cursor >> 12];
	*mixbuf++ += smp * volume;
	cursor += delta;


loop-event-checker: <all cases, if loop-event, 17 clk>
	do	{
		<default-loop>
		event_cursor -= event_delta;
		}
	while( event_cursor >= 0 ); 


bresenham: (volume == MAX, delta < 1.0, 9.2 clk)
	frac += delta;
	if(frac < delta) smp = *sample++;
	*mixbuf++ += smp << 8;


bresenham with volume: (volume != MAX, delta < 1.0, 10.6 clk)
	frac += delta;
	if(frac < delta) smp = *sample++ * volume;
	*mixbuf++ += smp;


dual-channel bresenham: (volume == MAX, delta < 1.0, 2 channels, 13.4 clk)
	frac1 += delta1;
	if(frac1 < delta1) smp1 = *sample1++;
	frac2 += delta2;
	if(frac2 < delta2) smp2 = *sample2++;
	*mixbuf++ += (smp1 + smp2) << 8


dual-channel bresenham with volume: (volume != MAX, delta < 1.0, 2 channels, 16.2 clk)
	frac1 += delta1;
	if( frac1 < delta1) smp1 = *sample1++ * volume1;
	frac2 += delta2;
	if( frac2 < delta2) smp2 = *sample2++ * volume2;
	*mixbuf++ += smp1 + smp2;




// determine which one of the mixing routines to use:

void mix( samples )
	{

	int bresenham_waiting = -1;
	int bresenham_volume_waiting = -1;
	dc_offset = 0;

	for(i=0;i<channels;i++)
		{
		chan = channels[i];
		if( chan->sample == NULL)
			continue;
		dc_offset += chan->volume * 128;
		if( chan->volume == 0)
			update_sample_cursor(i); // no actual mixing
		else if( chan->event_cursor <= (chan->event_delta * samples) )
			loop_event_mix(i);
		else if((unsigned) chan->delta >= (1 << 12))
			default_mix(i);
		else if( chan->volume == 0x100 )
			{
			if( bresenham_waiting >= 0)
				{
				dual_bresenham_mix( bresenham_waiting, i );
				bresenham_waiting = -1;
				}
			else
				bresenham_waiting = i;
			}
		else	{
			if( bresenham_volume_waiting >= 0)
				{
				dual_volume_bresenham_mix( bresenham_volume_waiting, i );
				bresenham_volume_waiting = -1;
				}
			else
				bresenham_volume_waiting = i;
			}
		}
	if( bresenham_waiting >= 0)
		bresenham_mix( bresenham_waiting );
	if( bresenham_volume_waiting >= 0)
		bresenham_volume_mix( bresenham_volume_waiting );	
	
	downmix();
	}




// the prepare_cache function loads sample-data into the cache
// and generates a virtual sample pointer that can be used
// to address into the cache. It is not useful if 
//  chan_delta is not in range [0,1]

struct junk { int a,b,c,d };

u8 Cache[CACHE_SIZE];
u8 *prepare_cache(int chn, int samples)
	{
	chan = channels[chn];
	u8 *sample_ptr = chan->sample->position;
	u8 *sample_pos = sample_ptr + (chan->cursor >> 12);
	u8 *sample_end_pos = sample_pos + ((chan->delta * samples) >> 12) + 1;
	int area_size = (sample_end_pos - sample_pos + 3 + 15) >> 4;
	if( area_size > (CACHE_SIZE >> 4) || chan->delta < 0)
		return sample_ptr;
	sample_pos &= ~3;
	cacheptr = (struct junk *)Cache;
	sampleptr = (struct junk *)sample_pos;
	do	{
		*cacheptr++ = *sampleptr++;
		}
		while(--area_size);
	return Cache - (sample_pos - sample_ptr);
	}


tracker state that needs to be kept track of during module playing (mod/s3m/xm):
 - global state:
    - order, pattern and tick positions
    - tempo, BPM
    - global volume and slide amount
    - pattern delay timeout
    - loop start pos and loop count
 - per-channel state:
    - sample index and sample cursor (and direction if ping-pong-looped sample)
    - current note volume/pan, and volume/pan slide
    - current base-pitch (initial note +/- the accumulated effect of porta)
    - porta-amount/type, tone-porta target, glissando enable
    - vibrato, tremolo: waveform, waveform-position, speed, depth
       <maintained separately for instrument and pattern effects>
       <for pattern effects, FT2 allows to toggle on/off 
        vibrato waveform reset for new-notes (?)>
    - note-cut and note-delay timeouts
       <note that note delay will also delay any additional effects on the note>
    - tremor: on-time, off-time, current-position
    - arpeggio: current-position, note1, note2
    - retrig / multi-retrig: current-position, rate, volume-modifier
    - remembered parameters for several effects
    - envelope positions for volume and panning
    - note state (active, note-off, none); fadeout volume in case of note-off
 - computed per-channel state for the mixer to use:
    - final pitch, volume, panning position

 - module flags that affect playback:
    - tick-0 volume slide enable (ST3)
    - amiga/linear frequency table select (FT2)
    - amiga sample-frequency clamps (ST3)
    - per-channel default pan positions and mute flags (ST3)
 - questions <ANSWERS with ST 3.01b, FT2.06, CP2.0alpha> :

    - what does a sample offset command past end-of-loop actually do in MOD/ST3?
       <ANSWER> FT2 and ST3 both simply stop all playback always.
       if end-of-loop == end-of-sample, CP will play from start of loop
       if end-of-loop != end-of-sample, CP will play from the specified
       location to the end of file, never looping.
       
    -  Also, are sample offsets not on a note always ignored
       in all formats?
       <ANSWER> ST3 and FT2 always ignore it. CP ignores it for MOD/XM
         but executes it for S3M.       

    - does note-cut kill the note completely or just turn its volume to 0?
       FT2 claims the latter; what does MOD/ST3 do? 
       <ANSWER> FT2: note-cut just sets volume to 0. ST3: note-cut kills
         note. CP sets volume to 0 for XM/S3M and kills note for MOD.
         Interestingly, under FT2, if note-cut is combined with vol-slide
         in the vol-column, then the note-cut sets the volume to 0 in one tick,
         then the volume can be slid back up while staying in the row for
         the next ticks.

    -  Also, can MOD/ST3 kill
       a note if its volume just happens to be set to 0?
       <ANSWER> Neither FT2, ST3 nor CP kill the note by default.
        ST3 has a "Vol0 optimizations" which kills the note if it is 0
        for 3 full rows.

    - can pattern loop commands in different channels nest?
       <ANSWER> ST3: No. ST3 remembers only the last loop-start, and two
         loop ends at different location will cause the outer loop to
         loop forever while the inner loop loops N times per iteration
         of the outer loop. FT2, on the other hand, performs nesting 
         correctly (!). To perform nesting, we must:
          - keep a loop-start-position and loop counter for each channel
          - if we have 1 loop command, we execute it normally
          - if we have 2 loop-end commands on the same line and both have
             loops left to do, then the one that jumps back shortest
             is executed first. 
         FT2 does not allow matched loop-start and loop-end to be issued in
         different channels; this causes the loop-end to be confused about
         where to jump to. ST3 however allows loop-start and loop-end
         in different channels. ST3 even allows loop-start and loop-end
         to be placed in the same row, causing the single row to repeated
         for the specified number of times. ST3: Multiple loop ends in a row
         cause all except the first one to be ignored.
         
         CP collapses all the loops into
         a global effects column, which doesn't seem to do nesting. 
    
    
    - does global volume affect all playing notes or only new ones? If only 
       new notes, then "global volume" must actually be remembered on a
       per-channel basis, being updated only when a new note actually appears
       in the channel.
       <ANSWER> FT2: global volume affects already-playing notes. However,
         the Set-Global-Volume Gxy command in FT2 is buggy if it is issued in any
         other channel than 0: if issued in channel N, it affects channels
         N to last-channel correctly, but channels 0 to N-1 don't have the global
         volume updated until the next time a global volume command appears
         (if the new command is issued in channel N too, channels 0 to N-1
         are updated with the global volume of the PREVIOUS Gxy command !!)
         Global volume slides will however update global volume for all channels
         correctly.
         ST3: global volume only affects new notes. global volume also
         does not affect notes issued in the same TICK as the global volume
         command (notes that are issued in the same row but in a later tick
         with Note-Delay or Multi-Retrig are however affected by Global Volume)

    - just how does Multi-retrig work?
      <ANSWER> ST3: Multi-retrig re-triggers the note at the specified intervals.
        The re-trigger counter is reset at beginning of each row. Notes started
        with Multi-retrig are (usually) killed at the end of the row.
        If you don't supply instrument or note, it remembers the last used 
        instrument/note. Unless you supply a new note or a volume command, 
        it also remembers last used volume and computes a new adjusted volume
        based on that one.
        FT2: similar to ST3, except that notes started with Multi-Retrig
        are NOT killed but keep playing normally after the end of the row. 
        The volume adjustment done per retrig will have any volume 
        column sliding added to/subtracted from it.
        CP doesn't implement the volume adjustment and doesn't
        kill the note, neither for S3M nor XM.
        
    - what the hell do the MOD effects E0x ("Amiga filter") and 
       EFx ("FunkInvert") do? Neither ST3 nor FT2 support them.

    - If multiple similar commands are supplied for an FT2 note, how do 
       they interact? (e.g. two portas, two vibratos, vibrato+porta, 
       two volume slides) ?
       <ANSWER>
       FT2:
        - Volume-tone-porta + effect-Porta: For each tick (when applicable), 
           the volume-tone-porta is applied first (clamping to target note), 
           then the effect-porta is applied (possibly taking the note back 
           away from the target note again). They are both applied to the 
           base-pitch. The volume-column porta is 16x as strong as
           effect-column porta.
        - Volume slide + volume slide: For each tick, the volume column
           slide is applied first and clamped, then the effect column slide
           is performed. If volume column slides up and effect column slides down,
           maximum volume cannot be reached; similarly, volume column slide down
           cannot bring volume to 0 if effect colum slides up. Something
           similar presumably applies to panning slide.
        - Vibrato: Vibrato in both columns causes the vibrato command in the
           volume column to be ignored, as if it just isn't there.
        - Tone porta in volume column + vibrato in effect column works
           as expected.
        - Vibrato in volume column + porta in effect column causes vibrato
           command to be ignored, even if the porta is a tone porta that has
           reached its target note. The vibrato is however NOT cancelled
           by fine-porta.
        - Set volume in effect column overrides set volume in volume column.
           Similarly, Set panning position in effect column overrides
           set panning position in volume column.
        - Volume-tone-porta + arpeggio: These work together as expected.
        - Volume-vibrato + arpeggio: Causes volume vibrato to be ignored.
        - Volume command + tremor doesn't seem to disturb the on-time/off-time
           behaviour of tremor.
        - If a fine volume slide appears in the volume command, and a Set
           Volume appears in the effect command, the Set Volume overrides the
           fine volume slide.
        - If a set volume appears in the volume command and a fine volume
           side appears in the effect command, the set command is done first,
           then the volume slide is applied to it.
           
        - in general, the rule appears to be:
           - if volume command is vibrato and the effect command affects
             pitch (porta, vibrato, arpeggio, but curiously not fine porta), 
             the volume command vibrato is ignored.
           - else the effects are applied volume command first, then effect
             command. If you slide vol/pan/pitch in both, then you need 
             to prepare two sets of slide amounts.
        
        - if tone porta is used together with multi-retrig, then
           the tone porta is generally applied, but the pitch is reset to the
           note's initial value for each retrig. Setting a target note with
           the tone porta causes the Multi-retrig volume to be reset to the
           instrument default.
        
        - tone porta + note delay doesn't seem to behave in any remotely
           predictable manner. We can probably do anything in this case.
        
       MOD, ST3:There seems to no way to feed MOD/ST3 two conflicting commands,
       so this is not an issue.
       
    - what does Tone Porta do if you supply different instruments for the
       original note and the tone porta target note?
       <ANSWER>
        ST3: If the instrument for the tone porta note exists, then
          we swap to the sample of that instrument (which starts playing
          from the beginning), but keep tracking the pitch as if we hadn't
          swapped sample (effectively ignoring the sample's sample rate).
          If the instrument doesn't exist, then we behave as if the
          already-playing instrument was still active. Tone Porta will
          begin playing the new sample from the old pitch even if the
          original sample ended/was killed.          
        FT2: appears to ignore the new instrument, ans continues to play
          the old one. If the old one is not playing, the new instrument
          does NOT start playing.
          but the target note (or, more correctly, the 'period' of the
          target note) is still recorded as if the old note was playing. 
        CP: handles both S3M and XM correctly; MOD is treated like XM.
    
    - What happens when doing tone porta without a target note?
      <ANSWER>
       <both ST3 and FT2>
       Tone Porta remembers not the actual last target note that was
       supplied with it, but instead its 'period' (causing it to slide
       to a potentially unexpected note if you are currently playing a
       different instument than what was used last time tone porta was
       supplied with a target note). This memory is clobbered
       by ordinary notes in ST3 but not in FT2 (however Key-off in ST3
       does NOT clobber this memory). In FT2, the target note memory
       is shared between the volume and the effect column.
    
    - surprising interactions between tone porta and volume!
      <ANSWER>
       FT2: setting a target note for Tone Porta causes the note volume
         to be restored to the default volume for the instrument of
         the original note.
         This applies regardless of whether Tone Porta appears in the
         volume or effect column.
         
       ST3: note volume is "restored" to the the default volume of 
         instrument that ends up actually playing the sample (see above)
       
       CP restores the volume for all of XM, S3M, MOD.
       
    - does ping-pong sample looping repeat its endpoint samples twice?
      <ANSWER> YES.
    
    - what does tempo=0 result in, and it is ever used?
      <ANSWER>
       ST3: ignores the command; ST3 also ignores commands of BPM <= 0x20.
       FT2: FastTacker2 behaves as if the tempo becomes 65536 (yes, I tested). 
             At a BPM of 125, this means that the player will take nearly 
             22 minutes per row (!!).
       CP: ignores the command.
       
    - does Vibrato obey the same frequency table as Porta, with higher 
       notes resulting in larger relative frequency changes with the 
       Amiga table?
      <ANSWER> YES!   
       
    - do amiga sample-freq clamps (MOD, ST3) affect base-pitch or only
       final-pitch?
      <ANSWER> BOTH, at least in ST3. 
       
    - what are the frequency-clamps of the various systems???
      <ANSWER>
       - FT2: amiga table with rates given by 14.318 MHz clock ticks:
            tick rate seems to be clamped to range { 1, 32767 }.
            Yes, you can play a 14MHz sample :-/
       - FT2: linear table: about 32 to 520000 Hz (~14 octaves)
               if sample-freq goes too low, FT2 will cut the sample rather
               than clamping the freq. Excessively high sample-freqs are clamped.
       - ST3: "amiga limits": upper limit = 31568 Hz, lower limit = 4181 Hz
               these don't seem to correspond to any obvious tick counts.
       - ST3: no amiga limits: tick rate apparently clamped to range { 128, 32767 }
       - MOD: argh. presumably depends on system that they are originating from.
               
    - FT2: if Note delay is run on a note, will slide effects in the volume
      column be suppressed during the first tick that the note is actually
      played? Any other issues?
      <ANSWER>
       - Normal volume slide: YES. 
       - Fine volume slide: command is ignored
       - Set Volume and Set Panning Position are delayed together with the note,
          not affecting any previous playing notes (this is true for ST3 too)
       - Porta to note: erratic, meaningless to use
       Normal volume slide is not delayed, though; if a note is already
       playing, the slide will keep applying to that note until the
       delayed note is triggered. Panning slide behaves like volume slide
       in this respect. Note delay also affects Note-off "notes" as expected.
       
    - what happens if note-delay appears without a note or instrument?
      <ANSWER>
       FT2: If delay != 0 or if it appears during a pattern delay, 
        then it will trigger a note with the same 
        note/instrument as the last ordinary note that was issued.
        (last ordinary note does NOT include target notes for porta)
       ST3: It is ignored.
       
    - are note-cut and note-delay forgotten if their delays match or exceed the
      current ticks-per-row count? will note-delay+effect cause the effect to
      be forgotten too?
      <ANSWER>
      - FT2: YES.
      - ST3: YES. Note-delay with delay=0 also causes infinite delay, 
          causing entire note to be discarded
          Note-cut command with delay=0 is ignored
      - Not at all clear what happens in MOD.
      
    - are pattern effects, such as slides and multi-retrig, active during
      a pattern delay? 
      <ANSWER>
       FT2 and ST3 behave in the same way:
       - Set note/instrument, Set volume, set panning position 
          are evaluated only once.
       - Fine slides are evaluated only once
       - Other effects that affect sound directly are repeated during the delay
          (incl: multi-retrig, vibrato, arpeggio, volume/pitch/pan slides,
           tremor)
       - note-delay is triggered repeatedly during the pattern delay.
         ST3 will as usual ignore notes with note delay == 0; FT2 won't.
        
    - how does pattern delay interact with other commands?
      <ANSWER>
       - In FT2, multiple pattern delay commands on 1 row cause all except 
         the last one to be ignored. In ST3, multiple pattern delays
         cause all except the FIRST one to be ignored.
       - Both ST3 and FT2: pattern delay + a branch in same row causes 
          the jump to be taken without the pattern delay, and the delay
          is executed after jump has been taken. The delay overrides any
          pattern delays at the jump target. 'Branch' may be a taken 
          loop, a pattern break, or jump to position.
          
    - other interactions between branches ?
       - <FT2, ST3>Break, Jump; multiple such commands on a row cause
         only the last one to be executed.
       - <FT2>Both Break and Jump take precedence over pattern loops.
         <ST3>Pattern loops always take precedence over Break and Jump.
       - Jump command takes HEX argument, while pattern break is BCD.
       - <FT2>Pattern break past end of target pattern causes the break to go
         to start of pattern instead.
         <ST3>Pattern break past end of target pattern are IGNORED.
       - <FT2, ST3>Jump command pointing outside actual playing order goes
          to element 0.
       
                
    - are notes suceptible to effects after key-off?
      <ANSWER>
      If the volume envelope is not enabled for an instrument, key-off
      kills the note immediately. If it is enabled, then the instrument will
      keep playing for a time, during which it remains susceptible to
      all pettern effects. This applies to both ST3 and FT2 (note that volume
      envelopes don't exist under ST3 ).
      
    - what happens to multi-retrig and note delay if no note is supplied
      with them? 
      <ANSWER>
      <FT2> They work just fine, using the last ordinary note/instrument issued.
      <ST3> Multi-retrig plays; it uses whatever 'period' is left in the 
          channel after whatever played before it. Note delay is ignored.
      
    - <FT2> Will multi-retrig suppress a slide effect on first tick only or on every
      tick that a note is actually triggered? 
      <ANSWER>
       - Volume slides are suppressed on first tick only.
       - Portamento is suppressed on every tick with new note; it is
         reset to the note start position for every note retrig.
      
      What happens if multi-retrig
      with volume change and volume slide are supplied together?
    - Invalid/undefined parameters to volume slide commands:
       - ST3: DFF, Dxy where neither x nor y is 0 or F
          - DFF: causes a fine volume slide up by 15.          
          - Dxy where neither X nor Y is 0/F: Volume slide down by Y.
          - D00 causes previous volume slide command to be remembered.          
       - MOD, FT2: Axy, Hxy where not both X and Y are 0
          - Axy, Hxy: volume slide up takes precedence.
       Comment: if we take MOD/FT2 volume command bytes and restore them
           to valid values, then the byte is also a valid ST3 volume
           command byte, so it is adequate to have an ST3 volume command
           byte interpreter for MOD/FT2 volume commands.
       - MOD, FT2: Cxx and Gxx: set volume and global volume:
           These clamp their results to [0,64]
           ST3 Vxx set-global-volume is clamped to [0,64] too.
          
    - FT2: Multiple global volume slide commands in a row - what happens?
      <ANSWER>
        They are executed one by one, going from left to right in the 
        row during the current tick, "almost" summing them up. 
        For each time one such command has been executed, the volume 
        is clamped to <0,64>
        
      
    - need to test what happens if you supply instrument, note but not both
      at the same time (which formats allow this?). If this is possible,
      check interaction with tone porta.

    - 'strings' on FT2.exe indicates the presence of an undocumented command 
      K, which modifies subsequent sample offsets in units of 64Kbytes.
      The FT2 documentation however says that K is Key-off.
      Is this command actually implemented anywhere?
      <ANSWER>
        - In FT2, the K command actually implements a Note-Key-off command, 
          similar to Note-cut except that it does key-off instead of cut, 
          after the specified number of ticks. Similarly to note-cut and 
          note-delay, excessive tick count causes the command to be forgotten.
        
          K does NOT supply an extended-range sample offset.

    - How does Glissando work? Does it round to nearest note or does it
      apply a rounding direction dependent on slide direction? Will swapping
      between different porta types toggle Glissando on/off? Does it round
      to correct notes for all sample-freqs or nerely if the sample-freq
      is 8363 Hz +/- an integer number of halfnotes? Do ST3 and FT2 support it?
       - Rounding mode is AGAINST the slide direction.
      Glissando appears to work as follows:
       - When a note of an instrument is triggered, we generate a virtual
         table of all integer-step halfnotes up and down for the current 
         instrument.
         Then, for each time we do a tone porta, we do:
          1: Accumulate the porta value into an accumulated porta amount.
          2: If the accumulated porta amount is big enough to reach or cross
             a halfnote in the virtual table from the current period, 
             then we perform porta to that halfnote and subtract the porta
             amount from the accumulated porta amount; if we do this, we
             must repeat point 2. Else we stop, doing nothing at all.
         The virtual table is a bit problematic: for linear frequency table,
         the virtual table just consists of all numbers of the form N0 + i*64
         where N0 is initial note period and i is an integer; it is a bit
         worse for amiga frequency table - storing a ~120-entry actual table
         for each instrument is a bit expensive. We can cut pretty much
         all of that cost by storing just 1 such table for each sample frequency
         actually used in a module.
         
      
    - how does tremor work?
       ST3: the on-time and off-time are 1 tick longer than specified.
            they are NOT remembered, but assumed to be {1,1} if the
            command byte is zero.
            the counter that is used to determine on-time/off-time
            is NOT reset from one row to the next
       FT2: the on-time and off-time are now 2 ticks longer
            than specified; command byte = zero will cause last nonzero
            value to be remembered.
       When leaving a section of Tremor (going from one row where
         Tremor is activated to another one where it isn't), 
         if we left while in Off-time, then we stay in off-time playing nothing
         until any of the following happen:
          - any non-tremor command that changes volume. These commands
            will terminate the off-time and proceed as if the volume culling
            that happened due to tremor off-time never happened.
            These commands are: any volume set/slides
            and new-notes. Note that even though the sound blocking due to
            the off-time is cancelled, the actual tremor state of
            current on/off-time position must be retained. The tremor state
            can only be reset by a new-note.
          - tremor starts up again, and we re-enter the on-time/off-time loop
              
    - tremolo - ST3 uses "sticky changes" in the update of volume with
        tremolo, what is this supposed to mean?
       <ANSWER>
       <ST3> For each channel, we maintain a 'base volume'. This 'base volume'
       is set when a note is started or when there is a set-volume command -
       it is not actually modified by volume slide.
       Tremolo then modifies the note volume to 'base-volume' + tremolo.
       If there is no tremolo command, the note volume sticks, and volume
       slide will affect note volume only. 'base volume' appears to be 
       used by tremolo only.
       
       <FT2> Similar to ST3, except that Volume slide appears 
       to affect both 'base-volume' and note-volume, with the two 
       being slided (and clamped) separately.
       
       Vibrato, unlike tremolo, is NOT sticky.

    - do vibrato/tremolo waveform support "random" mode?
      <ANSWER>
       The common waveform types are 0=sine, 1=ramp-down, 2=square
        <FT2> Waveform type #3 is same squarewave as #2
        <ST3> Waveform type #3 is random
      
      
      
      
    - length and magnitude of the vibrato/tremolo waveforms?
       <FT2> the tremolo and vibrato waveforms repeat with a period of 
             64/speed ticks. (waveform position is NOT updated during the
             1st tick of a frame). Tremolo max amplitude 
             appears to be +/- amplitude_param * 4, meaning that 0xF
             causes amplitude to be +/- praxtically the entire volume range.
       
       <ST3> tremolo/vibrato waveforms repeat at same rate as in FT2.
             tremolo appears to have max amplitude half of FT2.
       
    - any issues with the vibrato/tremolo waveforms? YES INDEED
       The waveforms add to the volume and the note-period (positive
        values reduce the pitch). The waveforms are:
        - sine-wave: 
           <ST3> starts at max for tremolo, at 0 then increasing for vibrato,
                 range is <-max, max>
           <FT2> behaves like ST3.
        - squarewave
           <ST3> starts at max always. note that the levels are <0, +max>
           <FT2> starts at max always, levels are <-max, +max>        
        - ramp-down
           <ST3> starts at -max, then ramps up to +max. (causes ramp-UP for tremolo)
           <FT2> range <-max,+max>. starts in the middle for vibrato
                 the waveform used for tremolo is something else entirely:
                  - first half ramps up from 0 to max
                  - second half ramps down from 0 to -max
        - random
           <ST3> operates in range <-max, 0> only.
           <FT2> no such waveform.       
       
       
       
    - if we start a note, does fine volume-slide or fine-porta affect
      it immediately?
      <ANSWER>
       YES, both for ST3 and FT2
         Note that fine slides in the volume column for FT2 are applied in
         tick0 only; this means that if note delay is applied, then the
         volume slide won't be applied to the note.
       
    - set-finetune effect, how does it work?
       Parameter x is 0 to 15, it offsets the note being played
       by ((x/8)-8) halfnotes. Supported by FT2, but not ST3.
    
    - does glissando work in ST3/FT2, and does it support set-finetune?
       <FT2>: yes and yes. this applies equally in both amiga and linear
              frequency modes (!!!!)
       <ST3>: glissando works as expected, set-finetune is not supported.      
    
      so how do we support fast glissando with modest memory footprint 
          THEN ?????
       - still trivial with linear freq table
       - amiga freq table:
          - check if accumulated porta would cause note to cross
            one half-note boundary from its current position ????
            
       
    - interation with glissando & porta?
       <FT2>
       - if porta has been accumulated and glissando is turned off, 
         any accumulated porta is released. If porta up/down is 
         performed, accumulated porta is released too.
       - if we enter tone-porta and glissando is enabled, the tone
         is rounded to nearest integer note at start of tone porta;
         the amount of round-off performed is added to the cumulative porta
         (if rounding away from target; subtracted if rounding to target)
       
    - How fast is porta?
      <ANSWER>
      1 porta-unit = period +/- 4 units per frame 
     
     
    
    - how does effect memory work? Which effects share memory?
    
 - comments:
    - FT2 tremor command has on/off times 1 tick longer than documented.
       What happens if on/off time are both
    - ST3 file-format supports stereo samples; whether these work in ST3 or
       how they might interact with panning is unclear.
    - MOD doesn't store notes, but Amiga tick counts in the pattern.
       Round to nearest note at load time.
    - ST3 allows unused bytes in the play order (???)
    - ST3 supports adlib instruments - it's not clear if it is possible
       or worth the effort to try to generate PCM for them.
    - FT2 allows patterns of any length from 1 to 256; assuming anything
      about its pattern length is not safe. MOD and ST3 are hardwired to 64.
      Patterns without packing schemes are large enough to be a problem.
    - Amiga frequency table appears to cause porta/vibrato to
      increment/decrement Amiga tick count linearly; Amiga tick count
      is related to sample frequency by FREQ = 8363*1712/tick_count.
    - FT2 official .XM documentation has several known errors.
    - MOD exists in versions with 15 and 31 samples, and with many variations
      of magic bytes.
    - Some players/trackers define additional commands for the XM file format
      beyond what FT2 itself supports.
    - Pattern break command uses a BCD argument???

impulse tracker notes:
 - additional effects:
    - channel volume commands (set and slide)
    - ability to play >1 note per channel at the same time
       - last issued note is 'foreground', others are 'background'
          - most commands affect foreground notes only
       - new-note-actions for instruments and as pattern command
          - these are actions performed on background notes when
            new foregound note is played. There are also Duplicate Check types
            and actions, which compare instrument/note/sample before
            canceling a note.
       - note off/cut/fade commands for background notes
       - state needed for each background note would be:
          - sample index and cursor
          - note index (needed for NNAs)
          - envelope positions, note state (active or fading out), fadeout volume
          - each foreground AND background note needs an NNA too
    - panning vibrato
    - pitch envelopes for instruments
    - sustain loops in samples
    - effect to toggle volume envelopes on/off
    - global tempo slide command
    - pattern looping appears to be tracked on a per-channel basis (nestable?)
    - note-cut kills a note completely, it doesn't just turn the volume to 0.
 - flags: 
    - tick-0 vibrato update enable
    - global volume apply to new samples only or already playing samples



************************************
 DATA ACTUALLY STORED IN THE MODULE
************************************

Per-Module:
 - Module Name, module author name
 - Effect handling flags to handle MOD/S3M/XM different treatment 
     - S3M: volume slide in tick 0 enable
     - S3M vs XM, many small issues, as documented above
     - please use at least 64 bits for this flags field   
 - Linear/AMIGA frequency table selector
 - Period clamps for the frequency table being used
 - Number of channels (1 to 255)
 - Initial tempo and BPM (0 to 255)
 - Play order length
 - Play order repeat position
 - Per-channel: default panning position and initial volume
 - Per-channel: volume mute and global effects enable
 - Number of instruments
 - Number of patterns
 - Number of period-tables (see below)
 - pointer to the array of period-tables
 - pointer to the play-order
 - pointers to arrays of:
    - instrument pointers
    - pattern pointers
 

Play-order: contains pattern indices in the range 0 to 253.
  If the value 254 is encountered, skip immediately to the next entry.
  Play-order may have length 1 to 255.

Per-Instrument:
 - Name
 - Default Volume
 - Default Panning position
 - Volume, panning and pitch envelopes:
    - Enable, loop-enable, sustain-enable
    - Point count
    - Loop start and end
    - Sustain loop start & end (same value in XM)
    - For each point in the envelope: 
       - X position
       - Initial Y position
       - Y change per tick (signed, 16-bit)
 - Fadeout rate (16-bit)
 - New-note-action, duplicate-check-type, duplicate-check-action
     <redundant for non-impulse-tracker>
 - A number of samples associated with instrument
 - A map of samples to the various notes of the instrument
 - Pointers to the associated samples


Per-Sample:
 - Sample waveform location and length
 - Loop: start, end, loop-type <none, forward, ping-pong>
 - Sustain-loop: start, end, loop-type <>
 - Base note indicator:
    - If linear frequency table: a C5-note period offset 
        (0: C5 == 8363 Hz, 768 units = 1 octave)
    - If Amiga frequency table: an index into the period-table array.
 - Default volume (0 to 64)
 - Default panning (0 to 255)
 - Vibrato: speed, depth, sweep, waveform select
    (for XM, use same value for all samples of instrument
    Note: need at least 5 waveforms - sine, ramp-up, ramp-down, square, random)


Per-Pattern:
 - Number of rows (1 to 256)
 - Packed size (32-bit quantity)
 - Pointer to a list of row-pointers (intended to accellerate jumps into
    the pattern)
 - Pointer to actual packed pattern-data
 
 
Period-table:
 This is a table that contains the period to use for every
 one of the 120 notes from C-0 to B-9. The module contains 0 to 65535
 period tables, one for each actual sample frequency used in the module.
 Period tables are only used if Amiga frequency tables are used;
 usually the number of period tables should be very small.
 
 
 
 
 
 
 
// For tone-porta with Glissando, we need to 
// determine the period for the next note down and the next note up.
   
int find_next_note_amiga( 
	int current_period, // the period currently active for the sample. 
	int direction,      // 0 = slide to larger period, 1 = slide to smaller period
	u16 *period_table  // currently active period-table
	)
	{
	if(current_period >= period_table[0]) return period_table[0];
	if(current_period <= period_table[119]) return period_table[119];
	
	// use binary search to find the largest entry not larger than the
	// current entry. The entries are sorted in descending order.
	// need to debug this routine.
	int low_clamp = 0;
	int high_clamp = 119;
	int test_location = 60;
	for(i=0;i<7;i++)
		{
		if( period_table[test_location] > current_period )
			low_clamp = test_location;
		else
			high_clamp = test_location;
		test_location = (low_clamp + high_clamp) >> 1;
		}	
	
	if(period_table[test_location] == current_period)
		{
		if(direction == 0) return period_table[test_location-1]
		else return period_table[test_location+1]
		}
	else	
		{
		if(direction == 0) return period_table[test_location]
		else return period_table[test_location+1]
		}
	}
	
int find_next_note_linear(
	int current_period, // current period od the currently playing note
	int initial_period, // initial period of the currently playing note
	int direction // currently active period-table
	)
	{
	int period_change = current_period - initial_period;
	int next_note_above = ((period_change + 64) & ~63) + initial_period;
	int next_note_below = ((period_change - 64) & ~63) + initial_period;
	if(direction) return next_note_above;
	else return next_note_below;
	}
		

// code to apply a tone portamento effect to the current note.
struct tone_porta_tracker {
	u16 target_period; // the target period we are sliding to
	u16 initial_period; // initial period of current note
	u8 remembered_slide; // memory of past slide
	u8 glissando_enable; // glissando enable
	u16 cumulative_slide; // cumlative slide that has been held back by glissando
	};

// this function returns a period.
int apply_tone_porta( 
	int *base_period, // current base period of channel
	int slide_amount, // slide amount: 0=use remembered amount
	tone_porta_tracker *tp // struct to track tone porta+glissando state of channel
	)
	{
	// if we have reached target note, quit.
	if( *base_period == target_period) return current_period;
	// retrieve a remembered sldie amount, if applicable
	int slide = slide_amount ? slide_amount : tp->remembered_slide;
	// if glissando is enabled, we must check if our slide would
	// cross a half-note. If it would, then apply it, else
	// accumulate it.
	if(tp->glissando_enable)
		{
		resid_slide = slide + tp->cumulative_slide;
		slide_to_use = 0;
		int px_note = *base_period;
		do	{
			ppx_note = px_note;
			if( freq_table == TABLE_AMIGA )
				next_note = find_next_note_amiga(
					px_note,
					target_period > current_period,
					channel[i].sample->period_table
					);
			else
				next_note = find_next_note_linear(
					px_note,
					channel[i].initial_period,
					target_period > current_period 
					);
			difference = abs( next_note - px_note );
			if(difference <= resid_slide)
				{
				resid_slide -= difference;
				slide_to_use += differnce;
				px_note = next_note;
				}
			}
		while( difference <= resid_slide && ppx_note != px_note);
		tp->cumulative_slide = resid_slide;
		}
	// for slides without glissando, just keep slide amount
	// unaffected.
	else
		slide_to_use = slide;
	
	// apply slide; if it crosses the target period, we clamp it to
	// the actual target period.
	if(current_period > target_period)
		*base_period = MAX( *base_period - slide, target_period );
	else
		*base_period = MIN( *base_period + slide, target_period );
	
	}

u32 arpeggio_table[16] = {
	65536, 61858, 58386, 55108, 52015, 49096, 46340, 43740,
	41285, 38968, 36781, 34716, 32768, 30929, 27554, 26008 };



int apply_arpeggio( int base_period, u8 tick, u8 effect_byte )
	{
	int arpeggio_pos = tick % 3;
	switch arpeggio_pos {
		case 0: offset = 0;
		case 1: offset = (effect_byte >> 4) & 0xF;
		case 2: offset = effect_byte & 0xF;
		}
	if( freq_table == AMIGA )
		return (base_period * arpeggio_table[offset] + 0x32768) >> 16;
	else
		return base_period - (offset << 64);
	}




struct vibrato_tracker {
	u8 reset_vibrato_on_note,
	u8 vibrato_waveform_sel,
	u16 vibrato_position,
	u8 vibrato_magnitude };

s8 *vibrato_waveforms[] = {
	sine_waveform,
	ramp_up_waveform,
	ramp_down_waveform,
	square_waveform,
	random_waveform };


int get_vibrato_offset( vibrato_tracker *v )
	{
	s8 *wf_pointer = v->vibrato_waveforms[v->vibrato_waveform_sel];
	return wf_pointer[v->vibrato_position] * v->vibrato_magnitude;
	}


/*
Loop command. There are two loop schemes available:
 - Nested loops. Nested loops are created by placing the loop-start/end
   for an inner loop within the area of the loop-start/end for an outer loop.
   The loops must be placed in different channels.
   To implement nested loops:
    - we need to track loop-state for each channel.
    - if there are multiple loop-ends for a row, and more than 1 wants
      to jump backwards, we pick the one that jumps backwards the shortest.
   FastTracker2 and ImpulseTracker use nested loops.
   Loop nesting requires loop start and loop end commands to be
   placed in the same channel.

 - Non-nested loops. Under non-nested loops, the loop start and loop end
   can be placed in different channels. There is no per-channel looping
   state being tracked, only a bit of global state. ScreamTracker3
   uses non-nested loops.

 - In both schemes, we collect for the current row a channel index
   of a loop-end command to actually execute. The loop-end command
   is then executed at the end of the row.
*/

int process_loop_command( int loopcnt, int channel )
	{
	if(module->nested_loops)
		{
		if( loopcnt == 0 && channel->loop_active == false)
			{
			channel->loopstart = current_row;
			channel->loop_active = true;
			channel->loop_counter = 0;
			}
		else	{
			if( channel->loop_counter < loopcnt )
				{
				branch_flag = true;
				branch_loop_event = true;
				if( channel->loopstart > largest_recorded_loopstart )
					{
					largest_recorded_loopstart = channel->loopstart;
					loop_channel_to_process = channel;
					}
				}
			else
				channel->loop_active = false;
			}	
		}
	else	{
		if(loopcnt == 0 && global_state->loop_active == 0)
			{
			global_state->loopstart = current_row;
			global_state->loop_active = true;
			global_state->loop_counter = 0;
			}
		else	{
			if( channel->loop_counter < loopcnt )
				{
				branch_flag = 1;
				branch_loop_event = 1;
				loop_channel_to_process = channel;
				}
			else
				global_state->loop_active = false;
			}
		}
	}


 
struct tremor_tracker {
	u8 remembered_byte;
	u8 tremor_counter; // reset to 0 on new-note
	u8 tremor_internal_off_state; // internal on/off toggle bit. New-note resets to 0.
	u8 tremor_external_off_state; // 0=on, 1=hard off, 2=off, but can be turned on with vol-command

void process_tremor( u8 tremor_byte )
	{
	if( module->tremor_remember_byte && !tremor_byte )
		tremor_byte = remembered_byte;
	remebered_byte = tremor_byte;
	int tremor_on_time = 
		((tremor_byte >> 4) & 0xF) + 1 + ft2_tremor_correction;
	int tremor_off_time = 
		((tremor_byte & 0xF) + 1 + ft2_tremor_correction;
	if( tremor_internal_off_state && tremor_counter >= tremor_off_time )
		{
		tremor_internal_off_state = 0;
		tremor_counter = 0;
		}
	else if( !tremor_internal_off_state && tremor_counter >= tremor_on_time )
		{
		tremor_internal_off_state = 1;
		tremor_counter = 0;
		}
	else
		tremor_counter++;
	}

void init_note()
	{
	instr_index = pattern->get_instrument();
	instrument = instr_table[instr_index];
	if(!instrument) return;
	
	sample = instrument->sample[pattern_sample_table[note]];
	
	if( has_sample_offset_command )
		{
		if( (sample_offset << 8) >= sample->length )
			return;
		sample_pos = sample_offset << 8;
		}
	else
		sample_pos = 0;
	sample_direction = FORWARD;
	
	
	if(multi_retrigged)
		volume = multi_retrig_volume();
	else
		volume = sample->default_volume();
	
	
	if( has_finetune_command )
		finetune = command_byte & 0xF;
	else
		finetune = 0;
	period = get_period(note, finetune);
	initial_period = period; // initial period
	base_period = period; // base period, modified by portas only
	final_period = period; // final-period, after porta, vibrato, arpeggio
	
	tremor_counter = 0;
	tremor_internal_off_state = 0;
	tremor_external_off_state = 0;
	
	if(reset_vibrato_on_note)
		vibrato_position = 0;
	}
	
	
	
operation of tracker state machine:
 - If we are starting processing of a pattern, prepare
   pattern, in terms of both unpacking state and
   intra-pattern state (e.g. loop-state must be reset whenever we enter a pattern)
   
 - Fetch one row of the pattern
 - For each channel:
    - check for flow control effects. collect:
       - pattern break/jump-order command
       - loop command
       - pattern delay (to update a pattern-delay-counter)
 - For each tick:
    - for each channel:
       - check if there is a note or effect in the channel, and if
         we are processing the first tick. Apply the various notes and effects
         as needed, updating channel state (and global volume).
       - from channel state, compute final-frequency/sample-delta, final-volume
         and panning position. then perform mixing using these parameters.
 - after last tick:
    - if branch, then execute it
    - else if pattern-delay-counter != 0 then strip the fetched-row
       of one-shot effects and execute the rest of the row N times.
 - if we reach end-of-pattern, consult order for next pattern,
   then prepare that pattern and continue.
	
	
	
- the processing of a note in a channel:
   - If there is a note delay command: keep processing state for previous note
     as long as tick-count < delay, trigger current-note if tick-count == delay,
     process state for new note for new note.
   - Multi-retrig causes a new current-note to be triggered at a specified
     interval. The first note inherits sample volume, the subsequent ones
     take a look at current volume, then applies that volume + a modifier.
   - Otherwise trigger current-note and apply effect normally.
	



	
Under what circumstances can we actually kill a note in FT2?
 - End-of-sample: kills note.
 - No volume envelope: key-off kills note.
 - Volume envelope: key-off triggers fadeout; note is killed at fadeout = 0.
 - setting volume to 0 causes FT2 to keep tracking note (sample-pos, pan).
 - New note always kills old note
 - There is no other way to kill note.
NoteCut: sets volume to 0 under FT2, kills note under ST3.
ST3: Multi-Retrig kills the note at end-of-row, FT2 doesn't.

