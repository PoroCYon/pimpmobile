

Protracker comments:

 - Sample length, loop-start-pos and loop-length must all be multiples of 2.
    The MOD format supports samples up to 128 Kbytes (minus 2 bytes), 
    although Protracker is reported to support 64 Kbytes samples only. 
    LoopEnable+LoopLength==0 on a sample
    apparently causes Protracker to crash if the sample is ever played.
 - Sample looping behavior:
    If LoopStart is set to 0 (beginning of sample), then
    it plays through the entire sample once, then enters the loop. If loop
    start is placed anywhere else, it plays to the end of the loop, then
    starts from the beginning of the loop again.
    
 - Sample Offset command with looping:
    If LoopStart == 0 then cursor is placed at the specified location in the
    sample, then it plays to the end, then enters the loop. Placing the
    sample offset past the sample end causes it to enter the loop 
    at the start immediately.
    If LoopStart != 0, then placing the sample offset past the loop end causes
    the playback to start at the loop-start. Looping otherwise functions
    normally.
 
Fine-tune effects:
 - Each sample has a default fine-tune value in the range -8 .. +7.
   The pattern effect E5x treats x as a signed 4-bit value (thus 8..F represent
   negative numbers in the range -8 to -1), that is then used instead of
   the sample's default finetune value. 1 unit of the finetune = 1/8 halfnote.
   Tone Portamento with Glissando appears to obey the current note's 
   finetune when it comes to determining the steps for Glissando.

Tone-porta vs Glissando:
 - Glissando seems to work only during Tone Porta command. During the
   tone-porta, the slide is applied normally, applying to initial-period.
   But then, after slide calculation, the period is rounded DOWN to the next
   integer note (in effect rounding pitch UP) - this calculation
   doesn't affect initial-period, only final-period for the current tick.
   This has 2 caveats:
    - The effect of glissando on the period is NOT sticky: 
      When we don't do tone porta, the period will immediately
      revert back to initial-period.
    - During the FIRST tick of a row with a tone porta in it,
      glissando is NOT applied at all(!!!!). With low BPM, low speed, 
      and slow tone-porta, this causes a weird vibrato effect.

   Note that if the tone porta hits its target note/period, then
   glissando is ignored.

The mysterious effect EFx ("FunkInvert", "InvertLoop")
 - Even Protracker does not implement this effect at all.
   Should perhaps download the even older Noisetracker????

The effect E0x: AMIGA filter:
  x=0 turns filter ON, x=1 turns filter OFF. 
    The filter setting is global state.
    The filter appears to be an analog lowpass filter that is documented to
    provide at least 15db attenuation at 7Khz. Testing with WinUAE suggests
    that the filter is a 1st order filter that cuts the volume by about 3.3x at 2.1 Khz.
    For x >= 2, Protracker uses only the lowest bit to toggle filter-state.
    Should probably examine UAE source-code to see how it is implemented 
    [failed; the UAE source-code doesn't contain the filter at all]

Retrigger:
    The last triggered note continues to play
    after the row with the retrigger ends.
    If no note or instrument is supplied, then the retrigger uses the same 
    volume & period as whatever played last in the channel (need to check 
    against tremolo)
    (Note resets the period; instrument resets the volume)
    
    
Tone-porta:
    The target period (that is, period not note) of tone porta is remembered 
    across a set-note, just like in Fasttracker; also, the slide-target 
    is remembered across instrument changes,

Invalid commands:
    F00: apparenly stops the pattern, much like in Fasttracker2.
    Axy, x and y both != 0: causes a slide up by x.
    
Note-cut:
    Sets volume to 0 (volume can be restored later)
    Note-cut in tick 0 acts in tick 0, it isn't ignored.
    
Note-delay:
    Note-delay in tick 0 acts in tick 0, causing zero delay.
    Note-delay without an actual note is ignored (even if instrument != 0)
    Note-delay + note + pattern-delay causes note to be retrigged for each 
       frame of pattern-delay, even if note-delay = 0. In this particular case,
       note + delay=0 does NOT behave as a note with no delay command (which is NOT
       retrigged by the pattern-delay).

Note-cut and note-delay both:
    Delay >= speed causes the command to be forgotten.
       
Looping behavior:
    Loops nest, sort of; a loop counter and a loop start position is tracked for
    EACH CHANNEL, and a loop-end that is taken always jumps to the matching
    loop start in the same channel. A loop end command without a matching loop
    start command in the same pattern causes the loop command to jump to whatever
    pattern position we last received a loop-start for; if we haven't received
    a loop-start in the current channel at all during the playing of the current 
    song, the loop-end will jump to an unpredictable position 
    (this applies both to Protracker and Fasttracker; we should initialize
    to row 0/order 0 at start-of-play in our player).
    
    Protracker's behavior if there are multiple loop-ends on the same line
    appears to be rather, em, weird, but actually extremely simple. It seems to work 
    as follows:
     - If the loop counter for the channel is 0, then initialize it to loop count,
       else decrement it. After this is done, the rightmost channel with
       loop-end command and loop counter != 0 is used for the loopback; only if
       ALL channels with loop-end commands have loop counters == 0 do we proceed
       to the next row.
    This sometimes gives rather weird results in practice: if you e.g. set up two loops
    that have the same loop-start, same loop-end and the loop count arguments 
    are x and y, then the number of times the pattern-data between them is played 
    is given by: (x+1) * (y+1) / gcd((x+1),(y+1)) (!!!!)
    
    Two loop-ends in a channel without a loop-start between them causes an infinite
    loop; neither Protracker nor FT2 have any functionality for nesting loops that
    appear in the same channel or detecting infinite loops. Detecting infinite
    loops is however very easy. To detect infinite loops, we do as follows:
    For each channel, we record a loop-end field. 
     - At loop-start (or player-start), we set the loop-end field to CLEARED.
    At loop-end (regardless of whether the loop is taken or not), we do one of follows:
     - If the loop-end field is CLEARED, then we record our current loop-end position
       into the field, and everything is OK.
     - If the loop-end field is NOT CLEARED, we check if the recorded loop-end
       matches our current position. If it does, then everything is OK;
       if it does not, then we have detected an infinite loop.
    This condition appears to be both necessary and sufficient to detect inf-loops for
    FT2; for Protracker, it will be necessary to also clear the loop-end
    fields whenever we enter a new pattern.
    
    <FT2> Fasttracker2 actually implements EXACTLY the Protracker behavior (including
    the weirdness with 2 loop-ends in same row), with one
    exception: Fasttracker2 remembers looping positions across pattern boundaries, so
    for loops we must record order position in addition to just pattern location.
    So that if you get a loop start in order 1, line 5, then a loop end in order 3, 
    line 20, it will loop through the appropriate locations in order 1, 2 and 3 (that is
    line 5 to the end in order1, the entire order2, line 1-20 in order3).


Loop/break/jump/pattern-delay interactions:
    Break vs jump in same row: the rightmost command is executed
    
    Break/jump vs loop-end: If loop ends appear on the same line as
      break/jump, they cause the loop counters to be updated normally, but
      the break/jump override the loop jumps, except for one curious issue:
      break + loop-end-that-would-be-taken on the same row causes a break
      to line 0 in the next pattern rather than a break to the specified line.
    
    Pattern-delay: is performed BEFORE the jump is taken (this applies to
      both Protracker and FT2; confusingly enough, both trackers actually
      move the cursor long before the pattern-delay has actually timed out)
      Loop end commands end up executing multiple times, which causes the
      loop to be registered as 'taken' at least once. This causes an infinite 
      loop unless there is also a jump/pattern-break command on the same line too.
      <FT2 has an extra safeguard that prevents the loop-counter from being
       updated repeatedly during a pattern-delay>
      
    
Frequency clamps:
   Protracker is not able to play notes above plain "B-3" (~31574 Hz). Trying to exceed
   this frequency gives the following results:
    - Porta up, finetune and vibrato are clamped to plain B-3.
    - Arpeggio gives strange bass sounds.
   Similarly, there is a low clamp for plain "C-1" (~4181 Hz), which cannot be
   exceeded with neither vibrato, finetune or porta down.
   It is possible in more modern trackers (FT2, ST3 etc) to write and read MOD files
   with notes beyond the range supported by Protracker; such MODs should be supported, 
   but not be assumed to obey Protracker's frequency clamps, and Protracker itself 
   won't really understand it (it will load it and display "???" for the notes it doesn't 
   understand, and play either nothing-at-all or random frequencies for those notes if
   you try to actually play the module). Such modules will need a considerably
   expanded note-table compared to the limited tables of Protracker/fmoddoc.
    
    
Tremolo:
   Unlike ST3/FT2, Tremolo is NOT sticky; doing tremolo, then quitting, 
   causes the volume to immediately revert back to initial-volume.
   Tremolo amplitude appears to be similar to FT2 (max argument causes
   amplitude of about +/- 100% of full volume) 
   Tremolo appears to have the same issue as Glissando: it is NOT applied
   during tick0 of any row, causing an odd tremor-like effect if you set
   both speed and BPM very low.
   (it should be noted that neither FT2 or ST3 actually apply Tremolo during tick0, 
   but in FT2/ST3, this problem is usually masked by the stickiness of Tremolo).
   Volume-slide affects the initial-volume of tremolo, like FT2 and unlike ST3.


Vibrato:
   Vibrato is not sticky, and like tremolo/glissando, vibrato in
   Protracker just doesn't get applied during the 1st tick of each row,
   so low BPM + low tempo + high vibrato amplitude gives a toggling effect 
   not unlike arpeggio.
   
   <FT2>Vibrato isn't sticky in FT2 either, and FT2 doesn't apply vibrato
   during tick0 either, so how come FT2 doesn't exhibit the artifacts of Protracker?
   For this, FT2 requires some awareness of whether it did Vibrato in the previous row;
   so how does it do it? One way: for each channel, we keep a command mailbox.
   If at the beginning of a row, the command mailbox is nonempty, then
   we fetch the command in it, and execute it before doing anything else.
   For vibrato: at the end of a row with vibrato, we put a revert-period command
   in the mailbox. Under FT2, if the current row contains a vibrato, we discard
   this mailboxed command, otherwise we execute it. Such a mailbox is also useful 
   for implementing other nonpersistent effects, such as the 
   kill-note-after-multi-retrig semantic of ST3. Under Protracker, we could use
   the mailbox to implement the odd nonpersistence of Vibrato, Tremolo 
   and Glissando. There doesn't seem to be an immediate need to keep more
   than 1 entry per channel in the mailbox.
   

Pattern-delay and executing effects in tick 0:
   If we are repeating a row due to pattern-delay, then for each
   repetition during the pattern-delay we apparently execute effects in tick0
   that would otherwise have been suppressed during that tick.
   <need further checking; this applies at least to tremolo/vibrato/tone-porta
     in Protracker, dunno about ST3/FT2>
   
   
    
Left to test:
 - Are 8xx and E8x true no-ops in Protracker? And what is the ordinarily 
    accepted range of the arguments to these effects?
 - Tone porta: does it cease to apply glissando once it has reached its target note?
 - Vibrato/tremolo waveforms - any weirdnesses like the bizarre 
    tremolo "ramp-down" waveform of FT2 or the unbalanced square waveform of ST3?
 - Multiple pattern-delays in a row?


<ST3/FT2>: is Tremor effective in tick0? 

<FT2 finetunes>
  Each sample has an integer and a fractional part of a relative note
  (that is, relative to 8363 Hz)
  The fractional part (-/+ 1 halfnote), just like in MOD, is overridden by
  the Set-Finetune command (with loss of resolution; the default
  finetunes have precision 1/128 halfnotes, the set-finetune command only
  have precision of 1/8 halfnotes); the integer part is unaffected. The FT2
  set-finetune command takes an unsigned argument, where the value 8 indicates
  fine-tune = 0.
<ST3 finetunes> ST3 does not implement the finetune command.
  
<FT2 glissando>
  I don't think this is really that much more complicated than Protracker:
  the main differences being:
   - stickiness after a portamento, the current-period
     doesn't revert back to the initial-period (it will revert back if you
     do porta up/down or turn off glissando.
   - note is rounded to nearest-note rather than next note up. (the previous assumption
     that FT2 actually applied a rounding direction based on porta direction appears
     not to be correct; still need to check ST3 ...).
   - Like Protracker, FT2 doesn't actually apply Glissando during the 1st tick, 
     but in FT2 this is usually masked by the stickiness of current-period 
     (which also isn't updated during the 1st tick)
  Need to do more tests with ST3 glissando to determine if it is like FT2 or
  need its own special-casing.
<ST3 glissando>
 - Like Protracker, current-period reverts back to initial-period immediately
   if no tone-porta command is present.
 - Note is rounded to nearest-note, like in FT2.
 - Like Protracker/FT2, Glissando isn't actually applied during the first tick; 
   but if there is a tone porta in both previous and current line, then we must not
   undo glissando during the 1st tick (use mailboxing for this)
 
Glissando: ineffective after target note is reached?




Vibrato and Tremolo: waveform advance & reset:

Vibrato & Tremolo: 
<MOD, S3M, XM> The vibrato & tremolo waveform cursors advance only while actually 
running a vibrato/tremolo command; they are NOT reset if speed changes, and they are
neither reset nor updated on rows without commands on them.

Vibrato & Tremolo: reset on set-waveform-command (same results for both vib & trem)
<Protracker>: Nope.
<ST3>: Yes, if waveform-selected < 4.
<FT2>: Nope.

Waveform-reset-on-note: actually done on note or instrument (in the case where not
both are present)?
<Protracker>: Note
<ST3>: Note for Vibrato; Note-or-instrument for Tremolo
<FT2>: Instrument




------------------------------------

Channel-state:

 - contents of current note-slot

 - current-sample-pointer, loop-state, sample-cursor
 - current-sample-delta (computed from Current-period when needed)

 - Mailbox with an enum in it
 - Initial-volume
 - Current-volume
 - Initial-period
 - Current-period
 - Last-instrument
 - Last-note-index AND Last-note-period
 - Tone-porta-target-period
 - Loop-start, loop-end, loop-count <FT2, MOD: per-channel state>
 - Channel pan position
 
 - Note-state (ON, OFF, KILLED)
 
 - Instrument parameters
    - Envelope positions
    - Vibrato position
    - Fadeout state

 - Vibrato & tremolo waveform select
 - Vibrato & tremolo waveform positions
 - Glissando enable

 - Remembered effect parameters

 - Tremor state
    
 - "Global" volume state
    CurrentGlobalVol: the currently active "global" volume
      
 - Channel-volume


Global-state:
 - speed, BPM
 - Position: Order, pattern, row, tick
 - global-volume:
    - Last-issued Global-volume value
    - NextGlobalVol: the global volue that will come into effect
        from the next note onwards (ST3 only)
    (both ST3 and FT2 have screwed up global volume)
 - Pattern-delay counter
 - Loop-start, loop-end, loop-count <ST3: global state>
 - amiga filter state 

 - compatibility flags

 - state tied to pattern decoding




Issues left to test:
 behavior of note without instrument and instrument without note
  - Interactions with FT2 instrument state: envelopes, vibrato?
  - Protracker, ST3, FT2: behavior with 3xx and 5xx, Note-delay, Note-retrig
  - Interactions with vibrato/tremolo waveform reset?


The basic interactions (note, instrument, volume, tone-porta)

fmoddoc says:
- Sample is retrigged only if note 
   (with exceptions for retrig, tone-porta)
- Volume is reset to instr-volume if and only if instrument;
  volumes are reset to the default-volume of the specified instrument.
- Pitch is reset only if note


PROTRACKER:
fmoddoc is basically correct.
Tone-porta with an instrument change doesn't cause the sample
to be retrigged (but it does cause volume to be reset to the default
of the new instrument), but the next time there is an event that
causes the sample to retrigged (retrigger and/or new-note)
the new instrument will be used (comment: note-delay without an actual note doesn't
actually do anything)
If we supply instrument but no note, then the volume is reset to the
volume of the new instrument. This can be used to perform a (somewhat
hackish) set-volume + volume slide in the same row.

------------------------------------------
PROTRACKER IMPORTANT - DEFERRED NOTES!!!:
------------------------------------------
Here is a BIZARRE feature: when we execute an instrument-without-note with
another instrument that the one currently playing, playback of the currently
playing note doesn't stop immediately. Instead, when we reach the end or 
loop-end of the currently-playing note, then we jump to the loop-start of 
the new instrument and starts looping in that. If the new instrument doesn't have
a loop, the channel goes idle immediately. But even then, while the channel is idle,
issuing an instrument-without-note with an instrument with a loop in it causes that
instrument to play immediately, from its loop start (with the only condition
apparently being that there has been played at least 1 note in the channel before. )

If you want to make a module where you play samples back-to-back with no glitching, 
you can use this feature. Play the first sample (with or without looping), then issue an 
instrument-without-note for the 2nd sample (which must loop from start to end),
then when the 2nd sample has safely started, you can issue instrument-without-note again
(to yet another sample looping from start to end) and proceed on and on like this
indefinitely. When you need to quit, you simply issue an instrument-without-note
to an instrument without looping, and the last sample will quit at the natural time.

This feature can also be used to turn off an instrument in a way that ensures
that the instrument always stops right on a loop boundary, which could be useful
too.

Neither ST3, IT, FT2, CP nor IPLAY support this behavior; ST3 and IT 
(and Winamp) do a crude imitation of this behavior by swapping sample 
immediately.

So ... how the hell do we implement this feature without completely destroying
the mixer? Basically, we need to modify the loop event handler:
For the channel, we have the following data:
 - Current-sample
 - Next-sample
 - Sample-cursor
 - Sample-event
 - Loop-start
 - Loop-end
The mixer starts playing current-sample. If it then hits the sample-event,
it loads next-sample, loop-start and loop-end and uses all those to compute
new sample-cursor and a new sample-event.
The state machine wil then come and update Next-sample, Loop-start and Loop-end
whenever a new instrument is loaded.






FASTTRACKER 2:
A tone-porta with instrument change causes volume to revert to the 
default volume of the already-playing sample,
however the instrument is still updated so that later notes without
instrument use the new instrument.
If we supply instrument but no note, then the volume is always reset to the
default-volume to the currently-playing sample. Future notes w/o instrument
will still use the new instrument.

Retrig/note-delay does NOT use whatever pitch is present in the channel, but instead
the initial-pitch of the last issued note (excluding tone-porta-target-notes)
(it also uses the note-index of last-issued-note to determine which sample to play,
for multisampled instruments)
(Unlike Protracker, a note-delay without a supplied note will produce an actual note) 
Retrig/note-delay do obey instrument-without-note.

Invalid instruments are NOT ignored; what happens when trying to play
an invalid instrument is that the channel goes silent; 
initial-pitch and any tone-porta-targets set with the instrument behave
as if the instrument plays with C-5=8363 Hz (the default MOD setting)


Envelopes are reset whenever an Instrument is supplied (although if a new note
isn't triggered, they always revert to the initial position of the already-playing
instrument); they are not reset on notes without instruments. Note-delay or 
retrigger without instrument do NOT reset the Envelopes.

Note: When going past the end of the envelope, the envelope position
just sticks to the position of the last envelope node.

If you play a note without an instrument, and this causes an instrument
change from an already-playing note, then it does NOT inherit the envelope
settings of whatever played before; if the new instrument doesn't have an envelope, 
then you shouldn't have problems (envelope processing turns off), but if it does, 
then Fasttracker behaves unpredictably - UNLESS you use the Lxx command to
manually set the envelope position. What we should do is probably as follows:
 - On new-instrument: reset envelope position to 0.
 - On new-note w/o instrument, set up the pointers to the envelopes as
    appropriate; then refresh the envelope tracking data structures (so that
    they have the same tick-positions as before, but in a different envelope)




SCREAMTRACKER 3:
 - If the instrument column contains an invalid instrument
   (that is, the instrument doesn't have a type appropriate
   for the channel: 'SMP' for non-adlib channels) then that instrument index
   is ALWAYS ignored, as if it just isn't there.
 - Note volume is reset to new-instrument volue if a valid instrument
   is set (true even with tone porta). Tone porta still works
   even if no instrument is set, but doesn't reset volume then.
 - Tone porta with note + instrument change causes sample to be retrigged
   from the start, but only if the new instrument is actually valid.
 - If we apply an instrument without a note, then:
    - if a sample is currently playing, then we switch to the new
      instrument WITHOUT modifying sample position or period/frequency
      (if this causes the sample position to exceed the end/loop-end of the
      new instrument, playback ceases immediately)
    - if there is no sample currently playing, then nothing new will be played.
      Interestingly enough, for this purpose, NoteOff 
      (^^ in the pattern's note-column) actually counts as a sample
      forever playing at 8290 Hz (with its sample position forever stuck at 1)
      (this virtual sample doesn't respond to porta, but NoteCut (SCx) does
      cause it to stop) [THIS CANNOT BE RELIED ON: this value is 8290 Hz in
      ScreamTracker 3.01-beta, but in ScreamTracker 3.21, this value
      is instead the value of the last sample playing, and it DOES respond
      to porta]
    



----------------------
Interaction between no-note/no-instrument and note-delay EDx
----------------------


PROTRACKER:
 - New-instrument + note-delay > 0 
 

FASTTRACKER 2:
 - the channel-instrument is updated immediately, even if note-delay >= speed
   Note-delay == 0 causes the previous note to be retriggered with previous instrument
   Note-delay > 0 causes new note to be triggered with the new instrument.
   Note-delay >= speed causes no new note to be triggered; the old one will
     keep playing, if present
   
 

-------------------
Interaction between no-note + effect 9xx (sample-offset)
-------------------

PROTRACKER:
The rules for the 9xx effect appear to be: 
 - for each channel there is a sample offset field.
 1: First, if instrument is supplied, then the field is set to zero
     BEFORE any of the steps below (This applies unconditionally; even if
     the instrument belongs to a tone porta)
 2: If 9xx is present, but xx == 00, then xx is remembered from the previous 9xx command
     and used instead of 00.
 3: If 9xx is present, then xx00 is added to the field before note is applied
 4: If both 9xx and note are present, the field value is used as sample offset,
     then xx00 is added to the field AGAIN!
 5: If note is present, but not 9xx, then the field value is still used
     as sample offset, but the field value isn't modified.
Additional notes:
 - Pattern delay does NOT cause 9xx to be re-evaluated over and over again
 - 9xx updates its effect memory even if it doesn't actually get applied to anything.
 - Retrigger note obeys the sample offset field too (of course, you must not
    supply an instrument, but you can supply a note and still expect it to work)


FASTTRACKER:
 - 9xx has an effect memory, but updates its effect memory ONLY if it 
    is actually used together with a note. 9xx not on a note is always a no-op.
 - There seems to be no sample offset field at all that actually survives from
    one row to the next; 9xx ONLY affects the note on its current row.


SCREAMTRACKER (effect named Oxx)
 - Oxx has NO effect memory; argument zero means offset zero (this is NOT a no-op)
 - There does seem to be a sample offset field which is reset by instrument and applied
    to notes without instruments, but it behaves differently from Protracker: 
    An Oxx command will initialize the sample offset field to xx00 rather than add to it
    (xx == 00 sets the sample offset field to 0)
 - Retrigger note does NOT obey the sample offset field (but Note-Delay does)
    but it does NOT by itself reset it either.










// when stepping from one element in the order,
// check if the next element exists, and carry out the appropriate
// actions if it doesn't.
fix_order_pointer( int desired_pos )
	{
	if( desired_pos >= order_length )
		{
		infinite_loop = true;
		fix_order_pointer( repstart );	
		}
	else	if( order[desired_pos] == 254)
			fix_order_pointer( desired_pos + 1 );
	else	{
		current_order_pointer = desired_pos;
		pattern_index = order[current_order_pointer];
		prepare_pattern( pattern_index );
		}
	}





first_tick = tick==0 && pattern_delay_timeout == 0;

if(first_tick)
	{
	read_pattern();
	for(i=0;i<channels;i++)
		{
		// first_tick: 
		// apply any commands that might be present in the mailbox
		// process note and instrument number:
		// If instrument is supplied, reset volume & pan position
		// If note is supplied, reset pitch & sample-position
		// effects that cause exceptions: 
		//       EDx (note delay; in this case, note+instrument are applied later)
		//       3xx and 5xx (note is used to update tone-porta-target-period)
		// also examine effects:
		// also apply tick0 effects, and collect parameters for non-tick0 effects


		// go through the effects of the current row
		// and determine what messages, if any, to put in the
		// channel mailboxes
		for(i=0;i<channels;i++)
			{
			
			perform_mailboxing();
			}
				
		}

else	{
	for(i=0;i<channels;i++)
		{
		// ticks other than first tick: apply non-tick0 effects, but don't
		// really do anything else
		
		switch( volume_byte & 0xF0 )
			{
			}
		
		switch( effect_byte )
			{
			
			
			case MULTI_FX:
				switch( effect_parameter & 0xF )
			}
		
		}

	}


// some actions are performed regardless of first/nonfirst tick,
// in particular regarding the instruments.
for(i=0;i<channels;i++)
	{
	// update instrument state
	if( channel->has_volume_envelope )
		envelope_advance( channel->volume_envelope );	
	}
	




// have we reached the last tick of the row yet?
// if we do, apply pattern delay, branches, loops if appropriate
// if none apply, then just step to the next pattern row
// or, if needed, to the next pattern.
tick++;
if(tick == speed)
	{
	if(pattern_delay_timeout)
		pattern_delay_timeout--;
	
	if(pattern_delay_timeout == 0)
		{
		
		// take a branch, if appropriate, or
		// just jump to the next row in the pattern
		if(branch)
			{
			if(pattern_break)
				{
				fix_order_pointer( current_order_pointer + 1 );
				if( break_target >= pattern_length )
					break_target = 0;
				pattern_pointer = break_target;
				}
			else if(order_jump)
				{
				fix_order_pointer( jump_target );
				pattern_pointer = 0;
				}
			else // looping
				{
				if(nested_looping)
					{
					channel *ch = channelinfo + active_command_channel;
					fix_order_pointer( ch->loop_start_order );
					pattern_pointer = ch->loop_start_row );
					}
				else	{
					fix_order_pointer( global_loop_start_order );
					pattern_pointer = global_loop_start_row );
					}
				}
			}
		else 	// no branch; just step to the next row.
			{
			pattern_pointer++;
			if(pattern_pointer >= pattern_length)
				{
				fix_order_pointer( current_order_pointer + 1 );
				pattern_pointer = 0;
				}
			}
		}
	tick = 0;
	}


// after all the state handling, collect a volume, a period and a panning position
// to initialize the channel structures for the mixer. The mixer must
// IGNORE killed channels.

for(i=0;i<channels;i++)
	{
	if( channel->state != KILLED )
		{
		volume = current_global_volue * channel_volume 
			* envelope_volume() * fadeout_volume * note_volume;
		delta = get_delta_from_period();
		panning = 
		// FT2 formula -- good or not?
   		FinalPan=Pan+(EnvelopePan-32)*(128-Abs(Pan-128))/32;
		}	
	}



  
  