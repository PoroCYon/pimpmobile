#include <gba_base.h>
#include <assert.h>
#include <stdio.h>
#include "math.h"

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

const u8 clz_lut[256] =
{
	0x8, 0x7, 0x6, 0x6, 0x5, 0x5, 0x5, 0x5, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};


#ifndef NO_LINEAR_PERIODS
unsigned get_linear_period(int note, int fine_tune)
{
	assert(fine_tune >= -8);
	assert(fine_tune <   8);
	
	int xm_note = note - (12 * 1); // we extended our note-range with one octave.
	
	return 10 * 12 * 16 * 4 - xm_note * 16 * 4 - fine_tune / 2;
//	return 10 * 12 * 16 * 4 - note * 16 * 4 - fine_tune / 2;
}

#include "linear_delta_lut.h"
unsigned get_linear_delta(unsigned period)
{
	unsigned p = (12 * 16 * 4 * 14) - period;
	unsigned octave        = p / (12 * 16 * 4);
	unsigned octave_period = p % (12 * 16 * 4);
	unsigned delta = linear_delta_lut[octave_period] << octave;

	// BEHOLD: the expression of the devil
	// this compiles to one arm-instruction
	delta = ((long long)delta * unsigned((1.0 / SAMPLERATE) * (1 << 3) * (1ULL << 32)) + (1ULL << 31)) >> 32;
	return delta;
}
#endif /* NO_LINEAR_PERIODS */

#ifndef NO_AMIGA_PERIODS
#include "amiga_period_lut.h"
unsigned get_amiga_period(int note, int fine_tune)
{
	assert(fine_tune >= -8);
	assert(fine_tune <   8);
	
	int mod_note = note - (12 * 5); // we extended our note-range with two octaves. (wtf is this 3 octave bias?)
	int index = mod_note * 8 + fine_tune + 8;
	
	if (index < 0)
	{
		return 0;
	}

	if (index > ARRAY_SIZE(amiga_period_lut))
	{
		/* hack. */
		return amiga_period_lut[ARRAY_SIZE(amiga_period_lut) - 1];
	}

	// TODO: handle entries outside of the mod-note range
	// clamping will be handled on the period later anyway
	
	return amiga_period_lut[index];
}

#include "amiga_delta_lut.h"
unsigned get_amiga_delta(unsigned period)
{
	unsigned shamt = clz16(period) - 1;
	unsigned p = period << shamt;
	unsigned p_frac = p & ((1 << AMIGA_DELTA_LUT_FRAC_BITS) - 1);
	p >>= AMIGA_DELTA_LUT_FRAC_BITS;

	// interpolate table-entries for better result
	int d1 = amiga_delta_lut[p     - (AMIGA_DELTA_LUT_SIZE / 2)]; // (8363 * 1712) / float(p);
	int d2 = amiga_delta_lut[p + 1 - (AMIGA_DELTA_LUT_SIZE / 2)]; // (8363 * 1712) / float(p + 1);
	unsigned delta = (d1 << AMIGA_DELTA_LUT_FRAC_BITS) + (d2 - d1) * p_frac;

	if (shamt > AMIGA_DELTA_LUT_FRAC_BITS) delta <<= shamt - AMIGA_DELTA_LUT_FRAC_BITS;
	else delta >>= AMIGA_DELTA_LUT_FRAC_BITS - shamt;

	// BEHOLD: the expression of the devil 2.0
	// this compiles to one arm-instruction
	delta = ((long long)delta * unsigned(((1.0 / SAMPLERATE) * (1 << 6)) * (1LL << 32)) + (1ULL << 31)) >> 32;
	return delta;
}
#endif /* NO_AMIGA_PERIODS */

